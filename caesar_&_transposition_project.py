# -*- coding: utf-8 -*-
"""Caesar & Transposition Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r-9nsfpoEioVCUhIKsPJ6okiijNPmdt0
"""

import string
import math
import sys
import traceback
import itertools
from collections import Counter

# ==========================================
# PART 1: KNOWLEDGE BASE (Embedded Data)
# ==========================================

COMMON_WORDS = {
    'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with',
    'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her',
    'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what', 'so', 'up',
    'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time',
    'no', 'just', 'him', 'know', 'take', 'people', 'into', 'year', 'your', 'good', 'some', 'could',
    'them', 'see', 'other', 'than', 'then', 'now', 'look', 'only', 'come', 'its', 'over', 'think',
    'also', 'back', 'after', 'use', 'two', 'how', 'our', 'work', 'first', 'well', 'way', 'even',
    'new', 'want', 'because', 'any', 'these', 'give', 'day', 'most', 'us', 'is', 'are', 'was', 'were',
    'has', 'had', 'been', 'very', 'much', 'great', 'should', 'before', 'long', 'right', 'used', 'me',
    'between', 'under', 'last', 'never', 'place', 'same', 'another', 'while', 'number', 'part', 'found',
    'world', 'still', 'might', 'must', 'hand', 'off', 'since', 'many', 'does', 'again', 'where', 'why',
    'help', 'talk', 'turn', 'start', 'show', 'hear', 'play', 'run', 'move', 'like', 'live', 'believe',
    'hold', 'bring', 'happen', 'write', 'provide', 'sit', 'stand', 'lose', 'pay', 'meet', 'include',
    'continue', 'set', 'learn', 'change', 'lead', 'understand', 'watch', 'follow', 'stop', 'create',
    'speak', 'read', 'allow', 'add', 'spend', 'grow', 'open', 'walk', 'win', 'offer', 'remember',
    'love', 'consider', 'appear', 'buy', 'wait', 'serve', 'die', 'send', 'expect', 'build', 'stay',
    'fall', 'cut', 'reach', 'kill', 'remain', 'suggest', 'raise', 'pass', 'sell', 'require', 'report',
    'decide', 'pull', 'return', 'explain', 'hope', 'develop', 'carry', 'break', 'receive', 'agree',
    'support', 'hit', 'produce', 'eat', 'cover', 'catch', 'draw', 'choose', 'cause', 'point', 'listen',
    'realize', 'place', 'close', 'information', 'student', 'system', 'program', 'question', 'work',
    'government', 'country', 'night', 'water', 'thing', 'result', 'business', 'study', 'issue', 'side',
    'group', 'process', 'teacher', 'data', 'research', 'education', 'member', 'law', 'car', 'city',
    'community', 'name', 'president', 'team', 'minute', 'idea', 'kid', 'body', 'information', 'back',
    'parent', 'face', 'others', 'level', 'office', 'door', 'health', 'person', 'art', 'war', 'history',
    'party', 'result', 'change', 'morning', 'reason', 'research', 'girl', 'guy', 'food', 'moment',
    'air', 'force', 'man', 'cat', 'cats', 'love', 'loves' # Added specific test words
}

# Expanded Trigram List for better detection of concatenated text
COMMON_TRIGRAMS = {
    'THE': 1.0, 'AND': 0.9, 'ING': 0.9, 'HER': 0.8, 'HAT': 0.8, 'HIS': 0.8, 'THA': 0.8,
    'ERE': 0.7, 'FOR': 0.7, 'ENT': 0.7, 'ION': 0.7, 'TER': 0.7, 'WAS': 0.7, 'YOU': 0.7,
    'ITH': 0.6, 'VER': 0.6, 'ALL': 0.6, 'WIT': 0.6, 'THI': 0.6, 'TIO': 0.6,
    'NTH': 0.6, 'STH': 0.6, 'OFT': 0.6, 'ETH': 0.6, 'ATE': 0.6, 'OUL': 0.5,
    'MAN': 0.5, 'CAT': 0.5, 'OVE': 0.5, 'VES': 0.5, 'LOV': 0.5 # Added some common patterns
}

# ==========================================
# PART 2: CRYPTOGRAPHY CORE (Caesar + Transposition)
# ==========================================

class CaesarCipher:
    def __init__(self, shift=0):
        self.shift = shift
        self.upper_alpha = string.ascii_uppercase
        self.lower_alpha = string.ascii_lowercase
        self.modulus = 26

    def _shift_char(self, char, shift_amount):
        if char in self.upper_alpha:
            idx = self.upper_alpha.index(char)
            return self.upper_alpha[(idx + shift_amount) % self.modulus]
        elif char in self.lower_alpha:
            idx = self.lower_alpha.index(char)
            return self.lower_alpha[(idx + shift_amount) % self.modulus]
        else:
            return char

    def encrypt(self, plaintext, key=None):
        shift = key if key is not None else self.shift
        return ''.join(self._shift_char(c, shift) for c in plaintext)

    def decrypt(self, ciphertext, key=None):
        shift = key if key is not None else self.shift
        return ''.join(self._shift_char(c, -shift) for c in ciphertext)


class TranspositionCipher:
    """
    Implements Columnar Transposition Cipher.
    Treats spaces and punctuation as valid characters to be shuffled.
    """
    def _get_key_sequence(self, key):
        """
        Converts a keyword (str) or int into a numeric permutation sequence.
        Example: "ZEBRA" -> [4, 1, 0, 3, 2] (Indices of letters in alphabetical order)
        """
        if isinstance(key, int):
            # If key is an integer, assume it's just the column width
            # with standard 0,1,2... order (mostly for testing, less secure)
            return list(range(key))

        # If key is a string or list of numbers
        if isinstance(key, str):
            # Sort the characters and determine their original indices
            # e.g. "CAB" -> A(1), B(2), C(0) -> Sequence [1, 2, 0]
            # Standard method: Rank letters alphabetically
            # "ZEBRA" -> A(1), B(2), E(3), R(4), Z(5) -> ranks
            # We want the indices of the columns to read.
            # "ZEBRA":
            # Sorted: A(4), B(2), E(1), R(3), Z(0) -> [4, 2, 1, 3, 0]
            # This sequence means: Read column 4 first, then 2, then 1...
            key_indexed = sorted(list(enumerate(key)), key=lambda x: x[1])
            return [k[0] for k in key_indexed]

        return key # Assume it's already a list of ints

    def encrypt(self, plaintext, key):
        key_seq = self._get_key_sequence(key)
        num_cols = len(key_seq)

        # Build grid
        grid = [''] * num_cols
        for i, char in enumerate(plaintext):
            col_idx = i % num_cols
            grid[col_idx] += char

        # Read off columns in key_sequence order
        ciphertext = []
        for col_idx in key_seq:
            ciphertext.append(grid[col_idx])

        return ''.join(ciphertext)

    def decrypt(self, ciphertext, key):
        key_seq = self._get_key_sequence(key)
        num_cols = len(key_seq)
        num_rows = math.ceil(len(ciphertext) / num_cols)
        num_empty_cells = (num_rows * num_cols) - len(ciphertext)
        num_full_cells = num_cols - num_empty_cells

        # The grid is conceptually filled row by row.
        # But we receive it column by column.
        # We need to calculate how many characters belong to each column.
        # Columns 0 to (num_full_cells - 1) have 'num_rows' chars.
        # Columns num_full_cells to end have 'num_rows - 1' chars.

        col_lengths = [0] * num_cols
        for i in range(num_cols):
            if i < num_full_cells:
                col_lengths[i] = num_rows
            else:
                col_lengths[i] = num_rows - 1

        # Now split the ciphertext into columns based on the key sequence.
        # The ciphertext comes in the order of key_seq.

        cols_data = {}
        current_idx = 0

        for col_idx in key_seq:
            # How long is this specific column (in the original grid)?
            length = col_lengths[col_idx]
            # Extract that chunk
            cols_data[col_idx] = ciphertext[current_idx : current_idx + length]
            current_idx += length

        # Reconstruct the grid
        plaintext = []
        for r in range(num_rows):
            for c in range(num_cols):
                # Check if this cell exists (handle the short columns at end)
                if c >= num_full_cells and r == num_rows - 1:
                    continue # This cell was empty in the original grid

                # Append character if index exists
                if r < len(cols_data[c]):
                    plaintext.append(cols_data[c][r])

        return ''.join(plaintext)


# ==========================================
# PART 3: AI RECOMMENDER (HYBRID HEURISTIC)
# ==========================================

class AIRecommender:
    def __init__(self):
        self.alpha = 0.7
        self.beta = 0.3

    def _clean_tokenize(self, text):
        if not text: return []
        translator = str.maketrans('', '', string.punctuation)
        clean_text = text.translate(translator).lower()
        return clean_text.split()

    def _get_dictionary_score(self, text):
        words = self._clean_tokenize(text)
        if not words:
            return 0.0
        matches = sum(1 for w in words if w in COMMON_WORDS)
        return matches / len(words)

    def _get_ngram_score(self, text):
        if not text: return 0.0
        clean_text = text.upper().replace(" ", "")

        if len(clean_text) < 3:
            return 0.0

        score = 0
        count = 0
        for i in range(len(clean_text) - 2):
            trigram = clean_text[i:i+3]
            if trigram in COMMON_TRIGRAMS:
                score += COMMON_TRIGRAMS[trigram]
            count += 1

        if count == 0: return 0.0
        return min(1.0, score / (count * 0.2))

    def analyze(self, text):
        dict_score = self._get_dictionary_score(text)
        ngram_score = self._get_ngram_score(text)

        # Dynamic Weighting Logic:
        # If dictionary score is 0 (likely concatenated text), rely 100% on N-Grams.
        if dict_score == 0.0 and len(text) > 5:
            final_score = ngram_score # Ignore the 0 from dictionary
        else:
            final_score = (self.alpha * dict_score) + (self.beta * ngram_score)

        preview_text = text if text else "[Empty]"

        return {
            "score": final_score,
            "dict_score": dict_score,
            "ngram_score": ngram_score,
            "preview": preview_text[:60] + "..." if len(preview_text) > 60 else preview_text
        }

# ==========================================
# PART 4: ATTACK MODULES
# ==========================================

class CaesarAttacker:
    def __init__(self):
        self.cipher = CaesarCipher()
        self.ai = AIRecommender()

    def attack(self, ciphertext):
        candidates = []
        print(f"\n[AI] Analyzing 26 possible candidates for: '{ciphertext[:20]}...'")
        for key in range(26):
            decrypted_text = self.cipher.decrypt(ciphertext, key)
            analysis = self.ai.analyze(decrypted_text)
            candidates.append({
                "key": key,
                "plaintext": decrypted_text,
                "score": analysis['score'],
                "details": analysis
            })
        candidates.sort(key=lambda x: x['score'], reverse=True)
        return candidates


class TranspositionAttacker:
    def __init__(self):
        self.cipher = TranspositionCipher()
        self.ai = AIRecommender()
        self.MAX_KEY_LEN_BRUTE = 7 # 7! = 5040 checks

    def attack(self, ciphertext):
        """
        Attempts to brute force column orders for key lengths 2 to MAX.
        """
        candidates = []
        print(f"\n[AI] Generating permutations for key lengths 2-{self.MAX_KEY_LEN_BRUTE}...")

        # Iterate through possible key lengths
        for k_len in range(2, self.MAX_KEY_LEN_BRUTE + 1):
            perms = itertools.permutations(range(k_len))

            for p in perms:
                try:
                    decrypted_text = self.cipher.decrypt(ciphertext, list(p))
                    analysis = self.ai.analyze(decrypted_text)

                    # CHANGED: REMOVED HARD FILTER "if analysis['score'] > 0.3"
                    # We now save everything and sort later.

                    candidates.append({
                        "key": f"Len {k_len} | {list(p)}",
                        "plaintext": decrypted_text,
                        "score": analysis['score'],
                        "details": analysis
                    })
                except Exception:
                    continue

        # Sort desc
        candidates.sort(key=lambda x: x['score'], reverse=True)

        # Return only top 100 to keep UI clean, but having scanned ALL of them.
        return candidates[:100]

# ==========================================
# PART 5: USER INTERFACE (CLI)
# ==========================================

def print_separator():
    print("-" * 60)

def main():
    try:
        caesar = CaesarCipher()
        caesar_cracker = CaesarAttacker()
        trans = TranspositionCipher()
        trans_cracker = TranspositionAttacker()

        print_separator()
        print("      CRYPTO PROJECT: PHASE 1 & 2")
        print("      (Caesar & Columnar Transposition + AI)")
        print_separator()

        while True:
            print("\nMAIN MENU:")
            print("1. Caesar Cipher Tools")
            print("2. Transposition Cipher Tools")
            print("3. Exit")

            main_choice = input("Select Cipher (1-3): ").strip()

            if main_choice == '1':
                # --- CAESAR SUBMENU ---
                print("\n[Caesar Mode]")
                print("1. Encrypt")
                print("2. Decrypt (Known Key)")
                print("3. Attack (Unknown Key)")
                sub = input("Choice: ").strip()

                if sub == '1':
                    txt = input("Plaintext: ")
                    k = int(input("Shift (0-25): "))
                    print(f"Result: {caesar.encrypt(txt, k)}")
                elif sub == '2':
                    txt = input("Ciphertext: ")
                    k = int(input("Shift (0-25): "))
                    print(f"Result: {caesar.decrypt(txt, k)}")
                elif sub == '3':
                    txt = input("Ciphertext: ")
                    res = caesar_cracker.attack(txt)
                    print_results(res)

            elif main_choice == '2':
                # --- TRANSPOSITION SUBMENU ---
                print("\n[Transposition Mode]")
                print("1. Encrypt (Keyword)")
                print("2. Decrypt (Keyword)")
                print("3. Attack (Brute Force Permutations)")
                sub = input("Choice: ").strip()

                if sub == '1':
                    txt = input("Plaintext: ")
                    k = input("Keyword (e.g., ZEBRA): ").strip()
                    print(f"Result: {trans.encrypt(txt, k)}")
                elif sub == '2':
                    txt = input("Ciphertext: ")
                    k = input("Keyword (e.g., ZEBRA): ").strip()
                    print(f"Result: {trans.decrypt(txt, k)}")
                elif sub == '3':
                    txt = input("Ciphertext: ")
                    res = trans_cracker.attack(txt)
                    print_results(res)

            elif main_choice == '3':
                break
            else:
                print("Invalid choice.")

    except Exception:
        print("\nCRITICAL ERROR:")
        traceback.print_exc()

def print_results(results):
    if not results:
        print("\n[AI] No likely candidates found.")
        return

    print_separator()
    print("TOP AI RECOMMENDATIONS")
    print_separator()
    print(f"{'RANK':<5} {'CONFIDENCE':<12} {'KEY INFO':<20} {'TEXT'}")

    limit = min(5, len(results))
    for i in range(limit):
        r = results[i]
        # Clean up preview for display
        preview = r['plaintext'][:30].replace('\n', ' ')
        print(f"#{i+1:<4} {r['score']*100:>5.1f}%       {str(r['key'])[:18]:<20} {preview}...")

    top = results[0]
    print("\n[AI ANALYSIS]")
    print(f"Selected: {top['key']}")
    print(f"Dict Match: {top['details']['dict_score']*100:.1f}% | N-Gram: {top['details']['ngram_score']*100:.1f}%")

if __name__ == "__main__":
    main()